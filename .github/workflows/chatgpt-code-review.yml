name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const { OpenAI } = require('openai');

        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });

        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');

            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;

                if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                  return null; // Skip invalid or workflow files
                }

                const header = lines.find(line => line.startsWith('@@'));
                const position = header ? parseInt(header.match(/\+\d+/)?.[0].slice(1), 10) : null;
                const addedLines = lines.filter(line => line.startsWith('+') && !line.startsWith('+++')).map(line => line.slice(1));

                if (!position || addedLines.length === 0) {
                  return null; // Skip invalid changes
                }

                return { filePath, position, addedLines };
              })
              .filter(Boolean); // Remove null values

            const feedbacks = [];

            for (const { filePath, position, addedLines } of changes) {
              const chunkSize = 800;
              for (let i = 0; i < addedLines.length; i += chunkSize) {
                const chunk = addedLines.slice(i, i + chunkSize).join('\n');
                const messages = [
                  {
                    "role": "system",
                    "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. Rules: ${JSON.stringify(rules)}. When returning the review, don't mention the broken rules, and if a part of a function or function breaks multiple rules, include the whyIssue and fix together instead of sending them separately in different objects. And as a reviewer you need to make sure to provide the correct line number in the diff where you found the issue. so that the review solution will be displayed correctly next to the issue.`
                  },
                  {
                    "role": "user",
                    "content": `
                    Review the following changes in the filePath \`${filePath}\`:
                    ${chunk}

                    Respond strictly in the following JSON format:
                    [
                      {
                        "line": the line number in diff where you found the issue,
                        "filePath": "<file_path>",
                        "issueDescription": "<short_description>",
                        "whyIssue": "<why_this_is_an_issue>",
                        "fix": "<code_snippet>"
                      }
                    ]
                    If there are no issues, respond with:
                    { "status": "pass" }
                    `
                  }
                ];

                try {
                  const response = await openai.chat.completions.create({
                    model: 'gpt-4',
                    messages,
                    max_tokens: Math.min(4000 - Math.ceil(messages[1].content.length / 4), 1000),
                    n: 1,
                  });

                  const feedbackContent = response.choices[0].message.content;
                  console.log(`Raw GPT Response:`, feedbackContent);

                  if (feedbackContent.trim() === '{ "status": "pass" }') {
                    console.log(`No issues found for ${filePath}`);
                    continue; // Continue to the next chunk
                  }

                  try {
                    const parsedFeedback = JSON.parse(feedbackContent);
                    parsedFeedback.forEach(item => {
                      feedbacks.push({ ...item, commitId: null });
                    });
                  } catch (jsonError) {
                    console.error(`Invalid JSON response for ${filePath}:`, feedbackContent, jsonError.message);
                  }
                } catch (error) {
                  console.error(`Error processing feedback for ${filePath}:`, error.message);
                }
              }
            }

            // Add commit hashes for each feedback entry
            feedbacks.forEach(feedback => {
              try {
                const command = `git blame -L ${feedback.line},${feedback.line} --line-porcelain -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`;
                feedback.commitId = execSync(command).toString().trim();
              } catch (error) {
                console.error(`Failed to get commit hash for ${feedback.filePath} at line ${feedback.line}:`, error.message);
              }
            });

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error);
            process.exit(1);
          }
        }

        generateFeedback();
        EOF

        node generate_feedback.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');

        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.PR_NUMBER;

            console.log('Fetching existing comments...');
            const existingComments = await octokit.pulls.listReviewComments({
              owner,
              repo,
              pull_number,
            });

            for (const { filePath, line, commitId, issueDescription, whyIssue, fix } of feedbacks) {
              const body = `${whyIssue}  in line${line} ${fix.length > 0 ? '\n```csharp \n' + fix + '\n ```' : ''}`;

              // Check for duplicates based on filePath, line, and issueDescription
              const commentExists = existingComments.data.some(
                (comment) =>
                  comment.path === filePath &&
                  comment.position === line &&
                  comment.body.includes(issueDescription)
              );

              if (commentExists) {
                console.log(`Skipping duplicate comment for ${filePath} at line ${line}`);
                continue;
              }

              console.log(`Posting comment for ${filePath} at line ${line}, commit ${commitId}`);

              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position: line + 1,
                  commit_id: commitId,
                });
                console.log(`Comment posted for ${filePath} at line ${line}`);
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
              }
            }
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        }
    
        postComments();
        EOF
    
        node post_comments.js
