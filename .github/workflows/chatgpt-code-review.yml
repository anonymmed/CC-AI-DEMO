name: ChatGPT Inline Code Review (Real-Time)

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 ws

    - name: Generate ChatGPT Feedback (Real-Time)
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const WebSocket = require('ws');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
        let ws;

        const connectToRealtimeAPI = () => {
          ws = new WebSocket("wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview", {
            headers: { Authorization: `Bearer ${process.env.OPENAI_API_KEY}`, "OpenAI-Beta": "realtime=v1" },
          });

          ws.on("open", () => {
            console.log("Connected to Realtime API.");
            sendSystemPrompt();
          });

          ws.on("message", (message) => {
            try {
              const event = JSON.parse(message.toString());
              if (event.type === "response.text.done") {
                const response = JSON.parse(event.response?.output?.[0]?.content?.[0]?.text || '{}');
                console.log("Processed response:", response);
                if (response.last) {
                  console.log("All issues processed. Closing connection.");
                  ws.close();
                } else {
                  postInlineComment(response);
                }
              } else {
               console.log('not done .. : Received message from server:', event);}
            } catch (err) {
              console.error("Error parsing message:", err.message);
            }
          });

          ws.on("close", () => console.log("WebSocket closed."));
          ws.on("error", (error) => console.error("WebSocket error:", error.message));
        };

        const sendSystemPrompt = () => {
          const rulesPath = '.github/workflows/rules.json';
          const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
          const systemPrompt = {
            type: "input_text",
            text: `You are an AI code reviewer. Use the following rules strictly to identify issues. Respond strictly in JSON format indicated by user prompts. Do not respond until all prompts are sent, indicated by the final input marked with "last: true". Include the correct line number and commit hash for each issue. Rules: ${JSON.stringify(rules)}.`,
          };

          ws.send(
            JSON.stringify({
              type: "conversation.item.create",
              item: { type: "message", role: "system", content: [systemPrompt] },
            }),
            () => {
              console.log("System prompt sent. Starting diff processing...");
              processDiff();
            }
          );
        };

        const processDiff = () => {
          console.log("Processing diff...");
          const diff = execSync(`git diff origin/${process.env.GITHUB_BASE_REF}`).toString();
          const changes = diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/(\S+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              if (!filePath || filePath.includes('workflows/')) {
                return null;
              }

              const addedLines = [];
              let lineOffset = 0;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('@@')) {
                  const hunkHeader = line.match(/\+(\d+)(?:,(\d+))?/);
                  lineOffset = hunkHeader ? parseInt(hunkHeader[1], 10) : 0;
                } else if (line.startsWith('+') && !line.startsWith('+++')) {
                  let commitId = 'unknown';
                  try {
                    commitId = execSync(
                      `git blame -L ${lineOffset},${lineOffset} --line-porcelain HEAD -- ${filePath} | head -n 1 | awk '{print $1}'`
                    ).toString().trim();
                  } catch (error) {
                    console.error(`Failed to get commit hash for ${filePath} at line ${lineOffset}:`, error.message);
                  }
                  addedLines.push({
                    lineNumber: lineOffset,
                    lineDiff: line.slice(1),
                    commitId,
                  });
                  lineOffset++;
                }
              }

              return { filePath, addedLines };
            })
            .filter(Boolean);

          changes.forEach((change, index) => {
            const isLast = index === changes.length - 1;
            const userPrompt = {
              type: "input_text",
              text: `Review the changes in ${change.filePath}:\n${JSON.stringify(change.addedLines, null, 2)}\nRespond in JSON format:\n[\n  {\n    "line": <line_number>,\n    "filePath": "<file_path>",\n    "issueDescription": "<short_description>",\n    "whyIssue": "<why_this_is_an_issue>",\n    "fix": "<code_snippet>",\n    "commitId": "<commit_id>"\n  }\n]\nIf no issues, respond with:\n{ "status": "pass" }${isLast ? ', "last": true' : ''}`,
            };
            if(isLast) {
              console.log("All changes processed. Sending final prompt.", userPrompt);
            } else {
             console.log("sending prompt:", userPrompt); 
            }
            ws.send(
              JSON.stringify({
                type: "conversation.item.create",
                item: { type: "message", role: "user", content: [userPrompt] },
              })
            );
          });
        };
        const postInlineComment = async (issue) => {
          const { filePath, lineNumber, commitId, issueDescription, whyIssue, fix } = issue;
          const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
          const pull_number = process.env.PR_NUMBER;

          try {
            await octokit.pulls.createReviewComment({
              owner,
              repo,
              pull_number,
              body: `${issueDescription}\n\n${whyIssue}\n\nSuggested Fix:\n\n\`${fix}\``,
              path: filePath,
              position: lineNumber,
              commit_id: commitId,
            });
            console.log(`Comment posted for ${filePath} at line ${lineNumber}`);
          } catch (error) {
            console.error(`Failed to post comment for ${filePath}:${lineNumber}`, error.message);
          }
        };

        connectToRealtimeAPI();
        EOF
        node generate_feedback.js
