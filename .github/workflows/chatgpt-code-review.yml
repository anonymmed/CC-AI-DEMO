name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}
    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} -- '*.cs' '*.ts' '*.js' '*.sql' > pr_diff.txt
    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const { OpenAI } = require('openai');
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });
        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
        const MAX_TOKENS = 4000;
        const AVERAGE_LINE_CHARACTERS = 80; // Approximate average line length
        const CHARACTERS_PER_TOKEN = 4; // Approximate characters per token
        const RESERVED_TOKENS = 2000; // Reserve for the response
        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;
                if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                  return null; // Skip invalid or workflow files
                }
                const header = lines.find(line => line.startsWith('@@'));
                const position = header ? parseInt(header.match(/\+([0-9]+)/)?.[1], 10) : null;
                const addedLines = [];
                let lineCounter = position || 0;
                let originalLine = lineCounter;
                for (const line of lines) {
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                  let commitHash;
                    try {
                        const blameOutput = execSync(`git blame -L ${lineCounter},${lineCounter} --line-porcelain HEAD -- ${filePath}`).toString().trim();
                        commitHash = blameOutput.split('\n')[0].split(' ')[0];
                        const originalLineMatch = blameOutput.match(/^\s*\d+\s+(\d+)\s+\d+\s+\d+/m);
                        originalLine = originalLineMatch ? parseInt(originalLineMatch[1], 10) : lineCounter; // Use current line if parsing fails
                        console.log(`commit hash is ${commitHash}, original line is ${originalLine}`);
                    } catch (error) {
                      console.error(`Failed to get commit hash for ${filePath} at line ${lineCounter}:`, error.message);
                      commitHash = 'unknown';
                    }
                    addedLines.push({
                      lineNumber: originalLine, // Use the original line number from blame
                      lineDiff: line.slice(1),
                      commitId: commitHash
                    });
                    lineCounter++;
                  }
                }
                if (addedLines.length === 0) {
                  return null; // Skip invalid changes
                }
                return { filePath, addedLines };
              })
              .filter(Boolean); // Remove null values
            const feedbacks = [];
            for (const { filePath, addedLines } of changes) {
              let chunk = [];
              let currentTokenCount = 0;
              for (const line of addedLines) {
                const lineTokenEstimate = Math.ceil((line.lineDiff.length || AVERAGE_LINE_CHARACTERS) / CHARACTERS_PER_TOKEN);
                if (currentTokenCount + lineTokenEstimate > MAX_TOKENS - RESERVED_TOKENS) {
                  // Process the current chunk
                  const messages = [
                    {
                      "role": "system",
                      "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. Rules: ${JSON.stringify(rules)}. Provide the correct line number for each issue so the review solution will be displayed correctly next to the issue.`
                    },
                    {
                      "role": "user",
                      "content": `
                      Review the following changes in the filePath \`${filePath}\`:
                      ${JSON.stringify(chunk, null, 2)}
                      Respond strictly in the following JSON format:
                      [
                        {
                          "line": <line_number>,
                          "filePath": "<file_path>",
                          "issueDescription": "<short_description>",
                          "whyIssue": "<why_this_is_an_issue>",
                          "fix": "<code_snippet>",
                          "commitId": "<commit_id_specific_to_the_line_that_have_issue>"
                        }
                      ]
                      If there are no issues, respond with:
                      { "status": "pass" }
                      `
                    }
                  ];
                  try {
                    const response = await openai.chat.completions.create({
                      model: 'gpt-4',
                      messages,
                      max_tokens: RESERVED_TOKENS,
                      n: 1,
                    });
                    const feedbackContent = response.choices[0].message.content;
                    console.log(`Raw GPT Response:`, feedbackContent);
                    if (feedbackContent.trim() === '{ "status": "pass" }') {
                      console.log(`No issues found for ${filePath}`);
                      continue;
                    }
                    try {
                      const parsedFeedback = JSON.parse(feedbackContent);
                      parsedFeedback.forEach(item => {
                        feedbacks.push(item); // Include commitId from chunk
                      });
                    } catch (jsonError) {
                      console.error(`Invalid JSON response for ${filePath}:`, feedbackContent, jsonError.message);
                    }
                  } catch (error) {
                    console.error(`Error processing feedback for ${filePath}:`, error.message);
                  }
                  // Reset for the next chunk
                  chunk = [];
                  currentTokenCount = 0;
                }
                chunk.push(line);
                currentTokenCount += lineTokenEstimate;
              }
              // Process any remaining lines in the last chunk
              if (chunk.length > 0) {
                const messages = [
                  {
                    "role": "system",
                    "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. Rules: ${JSON.stringify(rules)}. Provide the correct line number for each issue so the review solution will be displayed correctly next to the issue.`
                  },
                  {
                    "role": "user",
                    "content": `
                    Review the following changes in the filePath \`${filePath}\`:
                    ${JSON.stringify(chunk, null, 2)}
                    Respond strictly in the following JSON format:
                    [
                      {
                        "line": <line_number>,
                        "filePath": "<file_path>",
                        "issueDescription": "<short_description>",
                        "whyIssue": "<why_this_is_an_issue>",
                        "fix": "<code_snippet>",
                          "commitId": "<commit_id_specific_to_the_line_that_have_issue>"
                      }
                    ]
                    If there are no issues, respond with:
                    { "status": "pass" }
                    `
                  }
                ];
                try {
                  const response = await openai.chat.completions.create({
                    model: 'gpt-4',
                    messages,
                    max_tokens: RESERVED_TOKENS,
                    n: 1,
                  });
                  const feedbackContent = response.choices[0].message.content;
                  console.log(`Raw GPT Response:`, feedbackContent);
                  if (feedbackContent.trim() === '{ "status": "pass" }') {
                    console.log(`No issues found for ${filePath}`);
                    continue;
                  }
                  try {
                    const parsedFeedback = JSON.parse(feedbackContent);
                    parsedFeedback.forEach(item => {
                      feedbacks.push(item); // Include commitId from chunk
                    });
                  } catch (jsonError) {
                    console.error(`Invalid JSON response for ${filePath}:`, feedbackContent, jsonError.message);
                  }
                } catch (error) {
                  console.error(`Error processing feedback for ${filePath}:`, error.message);
                }
              }
            }
            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error);
            process.exit(1);
          }
        }
        generateFeedback();
        EOF
        node generate_feedback.js
    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.PR_NUMBER;
            // Initialize an array to hold the promises
            const commentPromises = [];
        
            // Loop through feedbacks and create a promise for each comment
            for (const { filePath, line, commitId, issueDescription, whyIssue, fix } of feedbacks) {
              const body = `${issueDescription} | ${whyIssue}  in line ${line} ${fix.length > 0 ? '\n```csharp \n' + fix + '\n ```' : ''}`;
        
              console.log(`Preparing comment for ${filePath} at line ${line}, commit ${commitId}`);
        
              // Push the promise into the array
              commentPromises.push(
                octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position: line,
                  commit_id: commitId,
                })
                  .then(() => {
                    console.log(`Comment posted for ${filePath} at line ${line}`);
                  })
                  .catch((err) => {
                    console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
                  })
              );
            }
        
            // Resolve all promises in parallel
            await Promise.all(commentPromises);
            console.log(`All ${commentPromises.length} review comments have been posted.`);
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        
        }
    
        postComments();
        EOF
    
        node post_comments.js
