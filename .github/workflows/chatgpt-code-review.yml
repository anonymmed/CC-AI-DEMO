name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 ws esprima

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const { execSync } = require('child_process');
        const crypto = require('crypto');
        const WebSocket = require('ws');
        const { Octokit } = require('@octokit/rest');

        const globalHash = crypto.randomBytes(16).toString('hex');

        function generateHash(input) {
          return crypto.createHash('sha256').update(input).digest('hex');
        }

        const connectToRealtimeAPI = () => {
          return new Promise((resolve, reject) => {
            const url = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17";
            const ws = new WebSocket(url, {
              headers: {
                "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
                "OpenAI-Beta": "realtime=v1",
              },
            });

            ws.on("open", () => {
              console.log("Connected to Realtime API.");
              resolve(ws);
            });

            ws.on("error", (error) => {
              console.error("WebSocket error:", error.message);
              reject(error);
            });

            ws.on("close", () => {
              console.log("Connection closed.");
            });

            ws.on("message", (message) => {
              const event = JSON.parse(message);

              if (event.type === "response.text.done") {
                const response = JSON.parse(event.response.output[0].content[0].text);

                if (response.last) {
                  console.log("All issues processed. Closing connection.");
                  ws.close();
                } else {
                  postInlineComment(response); // Post inline comment for each issue
                }
              }
            });
          });
        };

        const sendPrompt = (ws, globalHash, chunkHash, previousHash, filePath, chunk, isLastPrompt) => {
          const event = {
            type: "response.create",
            response: {
              modalities: ["text"],
              instructions: `
                - Wait for all prompts to be sent before responding.
                - Respond only after receiving a prompt with "isLastPrompt": true.
                - Analyze the provided code changes.
                - Identify one issue at a time.
                - Respond in JSON format with: line number, file path, issue description, why it is an issue, and a suggested fix.
                - Example response:
                  {
                    "line": 42,
                    "filePath": "main.cs",
                    "issueDescription": "Avoid hardcoding values.",
                    "whyIssue": "Hardcoded values are difficult to maintain.",
                    "fix": "Use constants instead.",
                    "last": false
                  }
                - Include "last: true" in the final response to indicate all issues have been processed.
              `,
              globalHash,
              chunkHash,
              previousHash,
              input: chunk,
              isLastPrompt,
            },
          };

          ws.send(JSON.stringify(event));
          console.log("Sent prompt:", event);
        };

        const postInlineComment = async (issue) => {
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          const { filePath, line, issueDescription, whyIssue, fix } = issue;

          try {
            await octokit.pulls.createReviewComment({
              owner: process.env.GITHUB_REPOSITORY.split('/')[0],
              repo: process.env.GITHUB_REPOSITORY.split('/')[1],
              pull_number: process.env.PR_NUMBER,
              body: `${issueDescription}\n\n${whyIssue}\n\nSuggested Fix:\n\n\`${fix}\``,
              path: filePath,
              position: line,
            });
            console.log(`Comment posted for ${filePath} at line ${line}`);
          } catch (error) {
            console.error(`Failed to post comment: ${error.message}`);
          }
        };

        const processDiff = async () => {
          const diff = execSync(`git diff origin/${process.env.GITHUB_BASE_REF}`).toString();
          const changes = diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/([\S]+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              if (!filePath) return null;

              const addedLines = [];
              lines.forEach((line, index) => {
                if (line.startsWith('+') && !line.startsWith('+++')) {
                  addedLines.push({
                    lineNumber: index + 1,
                    lineDiff: line.slice(1),
                  });
                }
              });

              return { filePath, addedLines };
            })
            .filter(Boolean);

          let previousChunkHash = null;
          const ws = await connectToRealtimeAPI();

          for (const { filePath, addedLines } of changes) {
            let chunk = [];
            for (let i = 0; i < addedLines.length; i++) {
              chunk.push(addedLines[i]);
              const isLastPrompt = i === addedLines.length - 1 && chunk.length > 0;

              if (chunk.length >= 10 || isLastPrompt) {
                const currentChunkHash = generateHash(JSON.stringify(chunk));
                sendPrompt(ws, globalHash, currentChunkHash, previousChunkHash, filePath, chunk, isLastPrompt);
                previousChunkHash = currentChunkHash;
                chunk = [];
              }
            }
          }
        };

        processDiff();
        EOF
        node generate_feedback.js
