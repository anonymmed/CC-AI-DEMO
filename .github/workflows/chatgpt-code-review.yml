name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const { OpenAI } = require('openai');

        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const rulesPath = '.github/rules.json';

            if (!fs.existsSync(rulesPath)) {
              console.error('Rules file not found at .github/rules.json');
              process.exit(1);
            }

            const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));

            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;

                if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                  return null; // Skip invalid or workflow files
                }

                const header = lines.find(line => line.startsWith('@@'));
                const position = header ? parseInt(header.match(/\+(\d+)/)?.[1], 10) : null;
                const addedLines = lines.filter(line => line.startsWith('+') && !line.startsWith('+++')).map(line => line.slice(1));

                if (!position || addedLines.length === 0) {
                  return null; // Skip invalid changes
                }

                return { filePath, position, addedLines };
              })
              .filter(Boolean); // Remove null values

            const feedbacks = [];

            for (const { filePath, position, addedLines } of changes) {
              const messages = [
                {
                  "role": "system",
                  "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Do not include any explanations or comments outside the JSON. Use the following rules for the review: ${JSON.stringify(rules)}`
                },
                {
                  "role": "user",
                  "content": `
                  Review the following changes in the filePath \\`${filePath}\\`:
                  ${addedLines.join('\n')}

                  Respond strictly in the following JSON format:
                  [
                    {
                      "line": <line_number>,
                      "filePath": "<file_path>",
                      "issueDescription": "<short_description>",
                      "whyIssue": "<why_this_is_an_issue>",
                      "fix": "<optional_fix_or_code_snippet_as_array>"
                    }
                  ]
                  If there are no issues, respond with:
                  { "status": "pass" }
                  `
                }
              ];

              try {
                const response = await openai.chat.completions.create({
                  model: 'gpt-4',
                  messages,
                  max_tokens: Math.max(1000 - Math.ceil(messages[1].content.length / 4), 50),
                  n: 1,
                });

                const feedbackContent = response.choices[0].message.content;

                if (feedbackContent.trim() === '{ "status": "pass" }') {
                  console.log(`No issues found for ${filePath}`);
                  continue;
                }

                const parsedFeedback = JSON.parse(feedbackContent);
                parsedFeedback.forEach(item => {
                  feedbacks.push({ ...item, commitId: null });
                });
              } catch (error) {
                console.error(`Error processing feedback for ${filePath}:`, error.message);
              }
            }

            // Add commit hashes for each feedback entry
            feedbacks.forEach(feedback => {
              try {
                const command = `git blame -L ${feedback.line},${feedback.line} --line-porcelain -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`;
                feedback.commitId = execSync(command).toString().trim();
              } catch (error) {
                console.error(`Failed to get commit hash for ${feedback.filePath} at line ${feedback.line}:`, error.message);
              }
            });

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error);
            process.exit(1);
          }
        }

        generateFeedback();
        EOF

        node generate_feedback.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');

        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.PR_NUMBER;

            console.log('Fetching existing comments...');
            const existingComments = await octokit.pulls.listReviewComments({
              owner,
              repo,
              pull_number,
            });

            for (const { filePath, line, commitId, issueDescription, whyIssue, fix } of feedbacks) {
              const body = `
                **Issue**: ${issueDescription}
                **Why it's an issue**: ${whyIssue}
                ${Array.isArray(fix) && fix.length > 0 ? `**Suggested Fix**:\n\\`\\`\\`\n${fix.join('\n')}\n\\`\\`\\`` : ''}
              `;

              // Check for duplicates based on filePath, line, and issueDescription
              const commentExists = existingComments.data.some(
                (comment) =>
                  comment.path === filePath &&
                  comment.position === line &&
                  comment.body.includes(issueDescription)
              );

              if (commentExists) {
                console.log(`Skipping duplicate comment for ${filePath} at line ${line}`);
                continue;
              }

              console.log(`Posting comment for ${filePath} at line ${line}, commit ${commitId}`);

              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position: line,
                  commit_id: commitId,
                });
                console.log(`Comment posted for ${filePath} at line ${line}`);
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
              }
            }
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        }

        postComments();
        EOF

        node post_comments.js
