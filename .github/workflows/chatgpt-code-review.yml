name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

env:
  GITHUB_EVENT_PULL_REQUEST_NUMBER: ${{ github.event.number }}

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}
    
    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    
    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > fetch_diff.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        async function fetchDiff() {
          try {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.GITHUB_EVENT_PULL_REQUEST_NUMBER;

            if (!pull_number) {
              console.error('PR number not found!');
              process.exit(1);
            }

            const response = await octokit.request('GET /repos/{owner}/{repo}/pulls/{pull_number}', {
              owner,
              repo,
              pull_number,
              headers: {
                Accept: 'application/vnd.github.v3.diff'
              }
            });

            fs.writeFileSync('pr_diff.txt', response.data);
            console.log('PR diff successfully fetched and saved.');
          } catch (err) {
            console.error('Error fetching PR diff:', err.message);
            process.exit(1);
          }
        }

        fetchDiff();
        EOF
        node fetch_diff.js

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { OpenAI } = require('openai');
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });

        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
        const MAX_TOKENS = 4000;
        const AVERAGE_LINE_CHARACTERS = 80;
        const CHARACTERS_PER_TOKEN = 4;
        const RESERVED_TOKENS = 2000;

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;

                if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                  return null; // Skip invalid or workflow files
                }

                const header = lines.find(line => line.startsWith('@@'));
                const position = header ? parseInt(header.match(/\+([0-9]+)/)?.[1], 10) : null;
                const addedLines = [];
                let lineCounter = position || 0;

                for (const line of lines) {
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                    addedLines.push({
                      lineNumber: lineCounter,
                      lineDiff: line.slice(1),
                      commitId: null // Placeholder for commitId to be added later
                    });
                    lineCounter++;
                  }
                }

                if (addedLines.length === 0) {
                  return null;
                }
                return { filePath, addedLines };
              })
              .filter(Boolean);

            const feedbacks = [];
            for (const { filePath, addedLines } of changes) {
              const chunk = addedLines;
                  const messages = [
                    {
                      "role": "system",
                      "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. 
                      If the last line in the provided lines appears to have incomplete context and could be resolved by subsequent lines, wait for the next input to confirm. If the issue persists after reviewing the next input, include it in the response.
                      Rules: ${JSON.stringify(rules, null, 2)}`
                    },
                    {
                      "role": "user",
                      "content": `
                      Review the following changes in the filePath \`${filePath}\`:
                      ${JSON.stringify(chunk, null, 2)}
                      Respond strictly in the following JSON format:
                      [
                        {
                          "line": <line_number>,
                          "filePath": "<file_path>",
                          "issueDescription": "<short_description>",
                          "whyIssue": "<why_this_is_an_issue>",
                          "fix": "<code_snippet>"
                        }
                      ]
                      If there are no issues, respond with:
                      { "status": "pass" }
                      `
                    }
                  ];
              try {
                const response = await openai.chat.completions.create({
                  model: 'gpt-4',
                  messages,
                  max_tokens: RESERVED_TOKENS,
                });

                const feedbackContent = response.choices[0].message.content;
                console.log(`Raw GPT Response:`, feedbackContent);

                if (feedbackContent.trim() !== '{ "status": "pass" }') {
                  const parsedFeedback = JSON.parse(feedbackContent);
                  feedbacks.push(...parsedFeedback);
                }
              } catch (err) {
                console.error('Error processing feedback:', err.message);
              }
            }

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error.message);
            process.exit(1);
          }
        }

        generateFeedback();
        EOF
        node generate_feedback.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        function mapLineToPosition(diff, filePath, lineNumber) {
          const lines = diff.split('\n');
          let currentFile = null;
          let positionInHunk = 0; // Position relative to the current hunk
          let lineInNewFile = 0; // Tracks the current line number in the new file

          for (const line of lines) {
            if (line.startsWith('@@')) {
              // Start of a new hunk
              const match = line.match(/@@ -\d+(,\d+)? \+(\d+)(,\d+)? @@/);
              if (match) {
                lineInNewFile = parseInt(match[2], 10); // Line number in the new file
                positionInHunk = 0; // Reset hunk position
              }
            } else if (line.startsWith('+++')) {
              currentFile = line.split(' ')[1]?.replace('b/', '');
            } else if (line.startsWith('+') && currentFile === filePath) {
              positionInHunk++;
              if (lineInNewFile === lineNumber) {
                return positionInHunk;
              }
              lineInNewFile++;
            } else if (!line.startsWith('-')) {
              // Context lines increase the line number in the new file but don't affect the hunk position
              lineInNewFile++;
            }
          }

          console.warn(`Could not map line ${lineNumber} in file ${filePath} to a diff position.`);
          return null;
        }

        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.GITHUB_EVENT_PULL_REQUEST_NUMBER;

            for (const { filePath, line, issueDescription, whyIssue, fix } of feedbacks) {
              const position = mapLineToPosition(diff, filePath, line);
              if (position === null) {
                console.warn(`Could not map line ${line} in file ${filePath} to a GitHub position.`);
                continue;
              }

              const body = `${issueDescription} | ${whyIssue} \n\n${fix ? `Fix:\n\`\`\`\n${fix}\n\`\`\`` : ''}`;
              console.log(`Posting comment for file ${filePath}, line ${line}, mapped position ${position}`);

              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position,
                });
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
              }
            }
          } catch (error) {
            console.error('Error during posting comments:', error.message);
            process.exit(1);
          }
        }

        postComments();
        EOF
        node post_comments.js  
