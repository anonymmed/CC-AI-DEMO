name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}
    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} -- '*.cs' '*.js' '*.ts' '*.sql' > pr_diff.txt
    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { OpenAI } = require('openai');
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });
        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
        const MAX_TOKENS = 4000; // Updated max tokens
        const AVERAGE_LINE_CHARACTERS = 80; // Approximate average line length
        const CHARACTERS_PER_TOKEN = 4; // Approximate characters per token
        const RESERVED_TOKENS = 2000; // Reserve for the response

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;
                if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                  return null; // Skip invalid or workflow files
                }
                const header = lines.find(line => line.startsWith('@@'));
                const position = header ? parseInt(header.match(/\+([0-9]+)/)?.[1], 10) : null;
                const addedLines = [];
                let lineCounter = position || 0;
                for (const line of lines) {
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                    addedLines.push({
                      lineNumber: lineCounter,
                      lineDiff: line.slice(1),
                      commitId: null // Placeholder for commitId to be added later
                    });
                    lineCounter++;
                  }
                }
                if (addedLines.length === 0) {
                  return null; // Skip invalid changes
                }
                return { filePath, addedLines };
              })
              .filter(Boolean); // Remove null values

            const feedbacks = [];
            for (const { filePath, addedLines } of changes) {
              let chunk = [];
              let currentTokenCount = 0;
              for (const line of addedLines) {
                const lineTokenEstimate = Math.ceil((line.lineDiff.length || AVERAGE_LINE_CHARACTERS) / CHARACTERS_PER_TOKEN);
                if (currentTokenCount + lineTokenEstimate > MAX_TOKENS - RESERVED_TOKENS) {
                  // Process the current chunk
                  const messages = [
                    {
                      "role": "system",
                      "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. 
                      If the last line in the provided lines appears to have incomplete context and could be resolved by subsequent lines, wait for the next input to confirm. If the issue persists after reviewing the next input, include it in the response.
                      Rules: ${JSON.stringify(rules, null, 2)}`
                    },
                    {
                      "role": "user",
                      "content": `
                      Review the following changes in the filePath \`${filePath}\`:
                      ${JSON.stringify(chunk, null, 2)}
                      Respond strictly in the following JSON format:
                      [
                        {
                          "line": <line_number>,
                          "filePath": "<file_path>",
                          "issueDescription": "<short_description>",
                          "whyIssue": "<why_this_is_an_issue>",
                          "fix": "<code_snippet>"
                        }
                      ]
                      If there are no issues, respond with:
                      { "status": "pass" }
                      `
                    }
                  ];
                  try {
                    const response = await openai.chat.completions.create({
                      model: 'gpt-4',
                      messages,
                      max_tokens: RESERVED_TOKENS,
                      n: 1,
                    });
                    const feedbackContent = response.choices[0].message.content;
                    console.log(`Raw GPT Response:`, feedbackContent);
                    if (feedbackContent.trim() === '{ "status": "pass" }') {
                      console.log(`No issues found for ${filePath}`);
                    } else {
                      try {
                        const parsedFeedback = JSON.parse(feedbackContent);
                        parsedFeedback.forEach(item => {
                          feedbacks.push(item);
                        });
                      } catch (jsonError) {
                        console.error(`Invalid JSON response for ${filePath}:`, feedbackContent, jsonError.message);
                      }
                    }
                  } catch (error) {
                    console.error(`Error processing feedback for ${filePath}:`, error.message);
                  }
                  // Reset for the next chunk
                  chunk = [];
                  currentTokenCount = 0;
                }
                chunk.push(line);
                currentTokenCount += lineTokenEstimate;
              }
              // Process any remaining lines in the last chunk
              if (chunk.length > 0) {
                const messages = [
                  {
                    "role": "system",
                    "content": `You are an AI reviewing code. Always respond in valid JSON format as described. Use the provided rules strictly to identify issues. 
                    If the last line in the provided lines appears to have incomplete context and could be resolved by subsequent lines, wait for the next input to confirm. If the issue persists after reviewing the next input, include it in the response.
                    Rules: ${JSON.stringify(rules, null, 2)}`
                  },
                  {
                    "role": "user",
                    "content": `
                    Review the following changes in the filePath \`${filePath}\`:
                    ${JSON.stringify(chunk, null, 2)}
                    Respond strictly in the following JSON format:
                    [
                      {
                        "line": <line_number>,
                        "filePath": "<file_path>",
                        "issueDescription": "<short_description>",
                        "whyIssue": "<why_this_is_an_issue>",
                        "fix": "<code_snippet>"
                      }
                    ]
                    If there are no issues, respond with:
                    { "status": "pass" }
                    `
                  }
                ];
                try {
                  const response = await openai.chat.completions.create({
                    model: 'gpt-4',
                    messages,
                    max_tokens: RESERVED_TOKENS,
                    n: 1,
                  });
                  const feedbackContent = response.choices[0].message.content;
                  console.log(`Raw GPT Response:`, feedbackContent);
                  if (feedbackContent.trim() === '{ "status": "pass" }') {
                    console.log(`No issues found for ${filePath}`);
                  } else {
                    try {
                      const parsedFeedback = JSON.parse(feedbackContent);
                      parsedFeedback.forEach(item => {
                        feedbacks.push(item);
                      });
                    } catch (jsonError) {
                      console.error(`Invalid JSON response for ${filePath}:`, feedbackContent, jsonError.message);
                    }
                  }
                } catch (error) {
                  console.error(`Error processing feedback for ${filePath}:`, error.message);
                }
              }
            }
            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error);
            process.exit(1);
          }
        }
        generateFeedback();
        EOF
        node generate_feedback.js

    - name: Map Diff Line Numbers
      id: map_diff
      run: |
        cat <<'EOF' > map_diff.js
        const fs = require('fs');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const diff = fs.readFileSync('pr_diff.txt', 'utf8');
        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
        console.log('Contents of feedbacks.json after writing:', feedbacks);

        function getMappedLine(diff, filePath, targetLine) {
          const lines = diff.split('\\n');
          let currentFile = null;
          let position = 0;

          for (const line of lines) {
            if (line.startsWith('@@')) {
              const match = line.match(/@@ -\\d+,\\d+ \\+(\\d+),/);
              if (match) {
                const startLine = parseInt(match[1], 10);
                if (targetLine >= startLine) position = startLine;
              }
            } else if (line.startsWith('+++')) {
              currentFile = line.split(' ')[1];
            } else if (line.startsWith('+') && currentFile === filePath) {
              if (position === targetLine) return position;
              position++;
            }
          }

          return null;
        }

        feedbacks.forEach(feedback => {
          feedback.addedLines.forEach(line => {
            const mappedLine = getMappedLine(diff, feedback.filePath, line.lineNumber);
            console.log(`Mapping: ${line.lineNumber} -> ${mappedLine}`);
            line.mappedLine = mappedLine;
          });
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        EOF
        node map_diff.js
        
    - name: Add Commit Hashes to Feedback
      id: add_commit_hashes
      run: |
        cat <<'EOF' > add_commit_hashes.js
        const fs = require('fs');
        const { execSync } = require('child_process');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));

        feedbacks.forEach(feedback => {
          feedback.addedLines.forEach(line => {
            try {
              if (line.mappedLine) {
                const commitHash = execSync(`git blame -L ${line.mappedLine},${line.mappedLine} --line-porcelain HEAD -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`).toString().trim();
                console.log(`Line ${line.mappedLine} in ${feedback.filePath} -> Commit ${commitHash}`);
                line.commitId = commitHash;
              } else {
                console.warn(`No mapped line for ${feedback.filePath}, original line: ${line.lineNumber}`);
                line.commitId = 'unknown';
              }
            } catch (err) {
              console.error(`Failed to fetch commit hash for line ${line.mappedLine} in ${feedback.filePath}: ${err.message}`);
              line.commitId = 'unknown';
            }
          });
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        EOF
        node add_commit_hashes.js
  
    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.PR_NUMBER;
            for (const { filePath, line, commitId, issueDescription, whyIssue, fix } of feedbacks) {
              const body = `${issueDescription} | ${whyIssue} in line ${line} ${fix.length > 0 ? '\n```csharp \n' + fix + '\n ```' : ''}`;
              console.log(`Posting comment for ${filePath} at line ${line}, commit ${commitId}`);
              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position: line,
                  commit_id: commitId,
                });
                console.log(`Comment posted for ${filePath} at line ${line}`);
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
              }
            }
            console.log(`All comments have been posted.`);
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        }
        postComments();
        EOF
        node post_comments.js
