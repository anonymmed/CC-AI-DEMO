name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}
    
    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    
    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} -- '*.cs' '*.js' '*.ts' '*.sql' > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { OpenAI } = require('openai');
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });
        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
        const MAX_TOKENS = 4000;
        const RESERVED_TOKENS = 2000;

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const feedbacks = [];

            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\\n');
                const filePathMatch = lines[0]?.match(/b\\/(\\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;
                if (!filePath) return null;

                let lineCounter = 0;
                lines.forEach(line => {
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                    feedbacks.push({
                      line: lineCounter,
                      filePath,
                      issueDescription: "Example issue description",
                      whyIssue: "Example why issue",
                      fix: "Example fix suggestion"
                    });
                    lineCounter++;
                  }
                });
              });

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
            console.log('Generated feedbacks:', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error.message);
            process.exit(1);
          }
        }

        generateFeedback();
        EOF
        node generate_feedback.js

    - name: Debug Generated Feedback
      run: cat feedbacks.json

    - name: Map Diff Line Numbers
      id: map_diff
      run: |
        cat <<'EOF' > map_diff.js
        const fs = require('fs');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const diff = fs.readFileSync('pr_diff.txt', 'utf8');
        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));

        function getMappedLine(diff, filePath, targetLine) {
          const lines = diff.split('\\n');
          let currentFile = null;
          let position = 0;

          for (const line of lines) {
            if (line.startsWith('@@')) {
              const match = line.match(/@@ -\\d+,\\d+ \\+(\\d+),/);
              if (match) {
                const startLine = parseInt(match[1], 10);
                if (targetLine >= startLine) position = startLine;
              }
            } else if (line.startsWith('+++')) {
              currentFile = line.split(' ')[1];
            } else if (line.startsWith('+') && currentFile === filePath) {
              if (position === targetLine) return position;
              position++;
            }
          }
          return null;
        }

        feedbacks.forEach(feedback => {
          const mappedLine = getMappedLine(diff, feedback.filePath, feedback.line);
          console.log(`Mapping Line: Original=${feedback.line}, Mapped=${mappedLine}`);
          feedback.mappedLine = mappedLine || feedback.line;
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        console.log('Updated feedbacks.json:', JSON.stringify(feedbacks, null, 2));
        EOF
        node map_diff.js

    - name: Debug Mapped Lines
      run: cat feedbacks.json

    - name: Add Commit Hashes to Feedback
      id: add_commit_hashes
      run: |
        cat <<'EOF' > add_commit_hashes.js
        const fs = require('fs');
        const { execSync } = require('child_process');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));

        feedbacks.forEach(feedback => {
          try {
            if (feedback.mappedLine) {
              const commitHash = execSync(`git blame -L ${feedback.mappedLine},${feedback.mappedLine} --line-porcelain HEAD -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`).toString().trim();
              console.log(`Mapped Line=${feedback.mappedLine}, Commit=${commitHash}`);
              feedback.commitId = commitHash;
            } else {
              console.warn(`No mapped line for file ${feedback.filePath}, line ${feedback.line}`);
              feedback.commitId = 'unknown';
            }
          } catch (err) {
            console.error(`Failed to get commit hash for ${feedback.filePath}:${feedback.mappedLine}`, err.message);
            feedback.commitId = 'unknown';
          }
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        console.log('Updated feedbacks.json with commit hashes:', JSON.stringify(feedbacks, null, 2));
        EOF
        node add_commit_hashes.js

    - name: Debug Commit Hashes
      run: cat feedbacks.json

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
        const pull_number = process.env.PR_NUMBER;

        feedbacks.forEach(feedback => {
          if (!feedback.mappedLine || feedback.commitId === 'unknown') {
            console.warn(`Skipping comment for ${feedback.filePath}, line ${feedback.line}`);
            return;
          }

          const body = `${feedback.issueDescription} | ${feedback.whyIssue}\n\n${feedback.fix ? `Fix:\n\`\`\`\n${feedback.fix}\n\`\`\`` : ''}`;
          console.log(`Posting comment for ${feedback.filePath}, line ${feedback.mappedLine}, commit ${feedback.commitId}`);
          
          try {
            octokit.pulls.createReviewComment({
              owner,
              repo,
              pull_number,
              body,
              path: feedback.filePath,
              position: feedback.mappedLine,
              commit_id: feedback.commitId,
            });
          } catch (err) {
            console.error(`Failed to post comment for ${feedback.filePath}:${feedback.mappedLine}`, err.message);
          }
        });
        EOF
        node post_comments.js