name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 ws esprima

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const { execSync } = require('child_process');
        const crypto = require('crypto');
        const WebSocket = require('ws');
        const { Octokit } = require('@octokit/rest');

        const globalHash = crypto.randomBytes(16).toString('hex');

        function generateHash(input) {
          return crypto.createHash('sha256').update(input).digest('hex');
        }

        const connectToRealtimeAPI = () => {
          const url = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17";
          const ws = new WebSocket(url, {
            headers: {
              "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
              "OpenAI-Beta": "realtime=v1",
            },
          });

          ws.on("open", () => {
            console.log("Connected to Realtime API.");
            processDiff(ws);
          });

          ws.on("message", (message) => {
            const event = JSON.parse(message.toString());
            console.log("Received message from server:", event);

            if (event.type === "response.text.done") {
              try {
                const response = JSON.parse(event.response?.output?.[0]?.content?.[0]?.text || '{}');
                console.log("Processed response:", response);

                if (response.last) {
                  console.log("All issues processed. Closing connection.");
                  ws.close();
                } else {
                  postInlineComment(response); // Post inline comment for each issue
                }
              } catch (err) {
                console.error("Error parsing response:", err.message);
              }
            }

            if (event.type === "error") {
              console.error("Error from server:", event.error);
            }
          });

          ws.on("close", () => {
            console.log("Connection closed.");
          });

          ws.on("error", (error) => {
            console.error("WebSocket error:", error.message);
          });

          return ws;
        };

        const addItemToConversation = (ws, content, callback) => {
          const event = {
            type: "conversation.item.create",
            item: {
              type: "message",
              role: "user",
              content: [
                {
                  type: "input_text",
                  text: content,
                },
              ],
            },
          };
          ws.send(JSON.stringify(event), callback);
          console.log("Sent conversation.item.create:", event);
        };

        const requestResponse = (ws) => {
          const event = {
            type: "response.create",
            response: {
              modalities: ["text"],
              instructions: `
                - Analyze the provided code changes.
                - Identify one issue at a time.
                - Respond in JSON format with: line number, file path, issue description, why it is an issue, and a suggested fix.
                - Example response:
                  {
                    "line": 42,
                    "filePath": "main.cs",
                    "issueDescription": "Avoid hardcoding values.",
                    "whyIssue": "Hardcoded values are difficult to maintain.",
                    "fix": "Use constants instead.",
                    "last": false
                  }
                - Include "last: true" in the final response to indicate all issues have been processed.
              `,
            },
          };
          ws.send(JSON.stringify(event));
          console.log("Sent response.create event.");
        };

        const postInlineComment = async (issue) => {
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          const { filePath, line, issueDescription, whyIssue, fix } = issue;

          try {
            await octokit.pulls.createReviewComment({
              owner: process.env.GITHUB_REPOSITORY.split('/')[0],
              repo: process.env.GITHUB_REPOSITORY.split('/')[1],
              pull_number: process.env.PR_NUMBER,
              body: `${issueDescription}\n\n${whyIssue}\n\nSuggested Fix:\n\n\`${fix}\``,
              path: filePath,
              position: line,
            });
            console.log(`Comment posted for ${filePath} at line ${line}`);
          } catch (error) {
            console.error(`Failed to post comment: ${error.message}`);
          }
        };

        const processDiff = (ws) => {
          const diff = execSync(`git diff origin/${process.env.GITHUB_BASE_REF}`).toString();
          const changes = diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/([\S]+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              if (!filePath) return null;

              const addedLines = [];
              lines.forEach((line, index) => {
                if (line.startsWith('+') && !line.startsWith('+++')) {
                  addedLines.push({
                    lineNumber: index + 1,
                    lineDiff: line.slice(1),
                  });
                }
              });

              return { filePath, addedLines };
            })
            .filter(Boolean);

          let delay = 0;

          for (const { filePath, addedLines } of changes) {
            for (let i = 0; i < addedLines.length; i += 50) { // Consolidate chunks into ~50 lines each
              const chunk = addedLines.slice(i, i + 50);
              const content = JSON.stringify(chunk, null, 2);

              setTimeout(() => {
                addItemToConversation(ws, content, () => {
                  console.log("Prompt sent for chunk:", chunk);
                  if (i + 50 >= addedLines.length) {
                    requestResponse(ws);
                  }
                });
              }, delay);

              delay += 1500; // Add delay to avoid rate limits
            }
          }
        };

        connectToRealtimeAPI();
        EOF
        node generate_feedback.js
