name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const { OpenAI } = require('openai');

        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });

        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');

            const changes = parseDiffWithLineNumbers(diff);
            const feedbacks = [];

            for (const { filePath, addedLinesWithNumbers } of changes) {
              const chunks = chunkWithLineNumbers(addedLinesWithNumbers);

              for (const chunk of chunks) {
                const feedback = await processChunk(chunk, filePath, rules);
                if (feedback) feedbacks.push(...feedback); // Append valid feedbacks
              }
            }

            // Add commit hashes for each feedback entry
            feedbacks.forEach(feedback => {
              try {
                const command = `git blame -L ${feedback.line},${feedback.line} --line-porcelain -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`;
                feedback.commitId = execSync(command).toString().trim();
              } catch (error) {
                console.error(`Failed to get commit hash for ${feedback.filePath} at line ${feedback.line}:`, error.message);
              }
            });

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error generating feedback:', error);
            process.exit(1);
          }
        }

        function parseDiffWithLineNumbers(diff) {
          return diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/(\S+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              if (!filePath || filePath.includes('workflows/') || filePath.includes('rules')) {
                return null; // Skip invalid or workflow files
              }

              const header = lines.find(line => line.startsWith('@@'));
              const match = header.match(/\+(\d+)/);
              let currentLine = match ? parseInt(match[1], 10) : null;

              const addedLinesWithNumbers = lines
                .filter(line => line.startsWith('+') && !line.startsWith('+++'))
                .map(line => ({ line: currentLine++, code: line.slice(1) })); // Extract code and increment line number

              return { filePath, addedLinesWithNumbers };
            })
            .filter(Boolean);
        }

        function chunkWithLineNumbers(addedLinesWithNumbers, chunkMinSize = 300, chunkMaxSize = 2000) {
          const chunks = [];
          let chunkBuffer = [];
          let chunkSize = 0;

          for (const { line, code } of addedLinesWithNumbers) {
            chunkBuffer.push({ line, code });
            chunkSize += code.length;

            if (chunkSize >= chunkMaxSize) {
              chunks.push(chunkBuffer);
              chunkBuffer = [];
              chunkSize = 0;
            }
          }

          if (chunkBuffer.length > 0) {
            chunks.push(chunkBuffer); // Add remaining lines
          }

          return chunks;
        }

        async function processChunk(chunk, filePath, rules) {
          const formattedChunk = chunk.map(({ line, code }) => `Line ${line}: ${code}`).join('\n');

          const messages = [
            {
              "role": "system",
              "content": `You are an AI reviewing code. Always respond in valid JSON format...`
            },
            {
              "role": "user",
              "content": `
              Review the following changes in the filePath \`${filePath}\`:
              ${formattedChunk}

              Respond strictly in the following JSON format:
              [
                {
                  "line": the exact line number in the file where you found the issue,
                  "filePath": "<file_path>",
                  "issueDescription": "<short_description>",
                  "whyIssue": "<why_this_is_an_issue>",
                  "fix": "<code_snippet>"
                }
              ]
              If there are no issues, respond with:
              { "status": "pass" }
              `
            }
          ];

          try {
            const response = await openai.chat.completions.create({
              model: 'gpt-4',
              messages,
              max_tokens: 1000,
            });

            const feedbackContent = response.choices[0].message.content;
            console.log(`Raw GPT Response:`, feedbackContent);

            const parsedFeedback = JSON.parse(feedbackContent);
            if (parsedFeedback.status === "pass") {
              console.log(`No issues found for ${filePath}`);
              return []; // Return empty array for "pass"
            }

            if (Array.isArray(parsedFeedback)) {
              return parsedFeedback; // Return feedback array if valid
            } else {
              console.error(`Unexpected feedback format:`, feedbackContent);
              return []; // Return empty array for unexpected feedback
            }
          } catch (error) {
            console.error(`Failed to parse GPT feedback:`, feedbackContent, error.message);
            return []; // Return empty array on error
          }
        }

        generateFeedback();
        EOF

        node generate_feedback.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');

        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = process.env.PR_NUMBER;

            console.log('Fetching existing comments...');
            const existingComments = await octokit.pulls.listReviewComments({
              owner,
              repo,
              pull_number,
            });

            for (const { filePath, line, commitId, issueDescription, whyIssue, fix } of feedbacks) {
              const body = `${whyIssue}  in line ${line} ${fix.length > 0 ? '\n```csharp \n' + fix + '\n ```' : ''}`;

              // Check for duplicates based on filePath, line, and issueDescription
              const commentExists = existingComments.data.some(
                (comment) =>
                  comment.path === filePath &&
                  comment.position === line &&
                  comment.body.includes(issueDescription)
              );

              if (commentExists) {
                console.log(`Skipping duplicate comment for ${filePath} at line ${line}`);
                continue;
              }

              console.log(`Posting comment for ${filePath} at line ${line}, commit ${commitId}`);

              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position: line,
                  commit_id: commitId,
                });
                console.log(`Comment posted for ${filePath} at line ${line}`);
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${line}`, err.message);
              }
            }
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        }
    
        postComments();
        EOF
    
        node post_comments.js
