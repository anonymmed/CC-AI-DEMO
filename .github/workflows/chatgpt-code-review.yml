name: ChatGPT Inline Code Review (Real-Time)

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 ws

    - name: Generate ChatGPT Feedback (Real-Time)
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const WebSocket = require('ws');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
        let ws;
        const completedMessages = [];

        const connectToRealtimeAPI = () => {
          ws = new WebSocket("wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview", {
            headers: { Authorization: `Bearer ${process.env.OPENAI_API_KEY}`, "OpenAI-Beta": "realtime=v1" },
          });

          ws.on("open", () => {
            console.log("Connected to Realtime API.");
            sendSystemPrompt();
          });

          ws.on("message", (message) => {
            try {
              const event = JSON.parse(message.toString());
              if (event.type === "response.text.done") {
                console.log("Completed response received:", event);
                completedMessages.push(event);
              } else {
                console.log(`Incoming message received of type ${event.type} and content ${JSON.stringify(event?.item?.content)}`);
              }
            } catch (err) {
              console.error("Error parsing message:", err.message);
            }
          });

          ws.on("close", () => console.log("WebSocket closed."));
          ws.on("error", (error) => console.error("WebSocket error:", error.message));
        };

        const sendSystemPrompt = () => {
          const rulesPath = '.github/workflows/rules.json';
          const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
          const systemPrompt = {
            type: "input_text",
            text: `You are an AI code reviewer. Use the following rules strictly to identify issues. Respond strictly in JSON format indicated by user prompts. Do not respond until all prompts are sent, indicated by the final input marked with \"last: true\". Include the correct line number and commit hash for each issue. Rules: ${JSON.stringify(rules)}.`,
          };

          ws.send(
            JSON.stringify({
              type: "conversation.item.create",
              item: { type: "message", role: "system", content: [systemPrompt] },
            }),
            () => {
              console.log("System prompt sent. Starting diff processing...");
              processDiff();
            }
          );
        };

        const processDiff = () => {
          console.log("Processing diff...");
          const diff = execSync(`git diff origin/${process.env.GITHUB_BASE_REF}`).toString();
          const changes = diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/(\S+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              if (!filePath || filePath.includes('workflows/')) {
                return null;
              }

              const addedLines = [];
              let lineOffset = 0;

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('@@')) {
                  const hunkHeader = line.match(/\+(\d+)(?:,(\d+))?/);
                  lineOffset = hunkHeader ? parseInt(hunkHeader[1], 10) : 0;
                } else if (line.startsWith('+') && !line.startsWith('+++')) {
                  let commitId = 'unknown';
                  try {
                    commitId = execSync(
                      `git blame -L ${lineOffset},${lineOffset} --line-porcelain HEAD -- ${filePath} | head -n 1 | awk '{print $1}'`
                    ).toString().trim();
                  } catch (error) {
                    console.error(`Failed to get commit hash for ${filePath} at line ${lineOffset}:`, error.message);
                  }
                  addedLines.push({
                    lineNumber: lineOffset,
                    lineDiff: line.slice(1),
                    commitId,
                  });
                  lineOffset++;
                }
              }

              return { filePath, addedLines };
            })
            .filter(Boolean);

          changes.forEach((change, index) => {
            const isLast = index === changes.length - 1;
            const userPrompt = {
              type: "input_text",
              text: `Review the changes in ${change.filePath}:
                    ${JSON.stringify(change.addedLines, null, 2)}
                    Respond in JSON format:
                    [
                      {
                        "line": <line_number>,
                        "filePath": "<file_path>",
                        "issueDescription": "<short_description>",
                        "whyIssue": "<why_this_is_an_issue>",
                        "fix": "<code_snippet>",
                        "commitId": "<commit_id>"
                      }
                    ]
                    If no issues, respond with:
                    { "status": "pass" }${isLast ? ', "last": true' : ''}`,
            };

            ws.send(
              JSON.stringify({
                type: "conversation.item.create",
                item: { type: "message", role: isLast ? "system" : "user", content: [userPrompt] },
              })
            );
          });
        };

        connectToRealtimeAPI();
        EOF
        node generate_feedback.js
