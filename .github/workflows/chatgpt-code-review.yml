name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}
    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 esprima

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} -- '*.cs' '*.js' '*.ts' '*.sql' > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { OpenAI } = require('openai');
        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });
        const rulesPath = '.github/rules.json';
        const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');
            const changes = diff.split('diff --git')
              .slice(1)
              .map(change => {
                const lines = change.split('\n');
                const filePathMatch = lines[0]?.match(/b\/(\S+)/);
                const filePath = filePathMatch ? filePathMatch[1] : null;
                if (!filePath) return null;

                const addedLines = [];
                for (const line of lines) {
                  if (line.startsWith('+') && !line.startsWith('+++')) {
                    addedLines.push({ lineNumber: null, lineDiff: line.slice(1) });
                  }
                }
                return { filePath, addedLines };
              })
              .filter(Boolean);

            fs.writeFileSync('feedbacks.json', JSON.stringify(changes, null, 2));
          } catch (err) {
            console.error('Error generating feedback:', err.message);
            process.exit(1);
          }
        }
        generateFeedback();
        EOF
        node generate_feedback.js

    - name: Map Diff Line Numbers
      id: map_diff
      run: |
        cat <<'EOF' > map_diff.js
        const fs = require('fs');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const diff = fs.readFileSync('pr_diff.txt', 'utf8');
        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));

        function getDiffLineNumber(diff, filePath, targetLine) {
          const lines = diff.split('\n');
          let position = 0; // GitHub's relative position counter
          let currentFile = null;

          for (const line of lines) {
            if (line.startsWith('@@')) {
              const match = line.match(/@@ -\d+,\d+ \+(\d+),/);
              if (match) {
                const diffStartLine = parseInt(match[1], 10);
                if (targetLine < diffStartLine) {
                  return null; // Target line is not in this hunk
                }
              }
            } else if (line.startsWith('+++')) {
              currentFile = line.split(' ')[1];
            } else if (line.startsWith('+') && currentFile === filePath) {
              position++;
              if (position === targetLine) {
                return position;
              }
            }
          }

          return null; // Line not found in diff
        }

        feedbacks.forEach(feedback => {
          feedback.addedLines.forEach(line => {
            const mappedLine = getDiffLineNumber(diff, feedback.filePath, line.lineNumber);
            console.log(`Expected Line: ${line.lineNumber}, Mapped GitHub Line: ${mappedLine}`);
            if (!mappedLine) {
              console.warn(`Line ${line.lineNumber} in ${feedback.filePath} not found in diff.`);
            }
            line.mappedLine = mappedLine;
          });
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        EOF
        node map_diff.js

    - name: Add Commit Hashes to Feedback
      id: add_commit_hashes
      run: |
        cat <<'EOF' > add_commit_hashes.js
        const fs = require('fs');
        const { execSync } = require('child_process');

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));

        feedbacks.forEach(feedback => {
          feedback.addedLines.forEach(line => {
            try {
              if (line.mappedLine) {
                const commitHash = execSync(`git blame -L ${line.mappedLine},${line.mappedLine} --line-porcelain HEAD -- ${feedback.filePath} | head -n 1 | awk '{print $1}'`).toString().trim();
                console.log(`Mapped Line: ${line.mappedLine}, Commit Hash: ${commitHash}`);
                line.commitId = commitHash;
              } else {
                console.warn(`No mapped line for ${feedback.filePath}, original line: ${line.lineNumber}`);
                line.commitId = 'unknown';
              }
            } catch (err) {
              console.error(`Failed to get commit hash for ${feedback.filePath} at line ${line.mappedLine}:`, err.message);
              line.commitId = 'unknown';
            }
          });
        });

        fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
        EOF
        node add_commit_hashes.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
        PR_NUMBER: ${{ github.event.number }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');
        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

        if (!fs.existsSync('feedbacks.json')) {
          console.error('Error: feedbacks.json does not exist.');
          process.exit(1);
        }

        const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
        const pull_number = process.env.PR_NUMBER;

        async function postComments() {
          for (const feedback of feedbacks) {
            for (const line of feedback.addedLines) {
              if (line.mappedLine && line.commitId !== 'unknown') {
                const body = `Issue: ${line.issueDescription} | Why: ${line.whyIssue} \n\n${line.fix ? 'Fix:\n```\n' + line.fix + '\n```' : ''}`;
                console.log(`Posting comment for file ${feedback.filePath}, line ${line.mappedLine}, commit ${line.commitId}`);
                try {
                  await octokit.pulls.createReviewComment({
                    owner,
                    repo,
                    pull_number,
                    body,
                    path: feedback.filePath,
                    position: line.mappedLine,
                    commit_id: line.commitId,
                  });
                } catch (err) {
                  console.error(`Failed to post comment for ${feedback.filePath}:${line.mappedLine}`, err.message);
                }
              } else {
                console.warn(`Skipping comment for unmapped or invalid line in ${feedback.filePath}, line ${line.lineNumber}`);
              }
            }
          }
        }

        postComments().catch(err => {
          console.error('Error during posting comments:', err.message);
          process.exit(1);
        });
        EOF
        node post_comments.js
