name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write

jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Cache Node.js Modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0 ws

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const { execSync } = require('child_process');
        const crypto = require('crypto');
        const WebSocket = require('ws');
        const { Octokit } = require('@octokit/rest');

        const globalHash = crypto.randomBytes(16).toString('hex');

        function generateHash(input) {
          return crypto.createHash('sha256').update(input).digest('hex');
        }

        const connectToRealtimeAPI = () => {
          const url = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17";
          const ws = new WebSocket(url, {
            headers: {
              "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
              "OpenAI-Beta": "realtime=v1",
            },
          });

          ws.on("open", () => {
            console.log("Connected to Realtime API.");
            processDiff(ws);
          });

          ws.on("message", (message) => {
            const event = JSON.parse(message.toString());
            if (event.type === "response.text.done") {
              try {
                const response = JSON.parse(event.response?.output?.[0]?.content?.[0]?.text || '{}');
                console.log("Processed response:", response);

                if (response.last) {
                  console.log("All issues processed. Closing connection.");
                  ws.close();
                } else {
                  postInlineComment(response);
                }
              } catch (err) {
                console.error("Error parsing response:", err.message);
              }
            }
          });

          ws.on("close", () => {
            console.log("Connection closed.");
          });

          ws.on("error", (error) => {
            console.error("WebSocket error:", error.message);
          });

          return ws;
        };

        const addItemToConversation = (ws, content, callback) => {
          const event = {
            type: "conversation.item.create",
            item: {
              type: "message",
              role: "user",
              content: [
                {
                  type: "input_text",
                  text: content,
                },
              ],
            },
          };
          ws.send(JSON.stringify(event), callback);
          console.log("Sent conversation.item.create:", event);
        };

        const requestResponse = (ws) => {
          const event = {
            type: "response.create",
            response: {
              modalities: ["text"],
              instructions: `
                - Analyze the provided code changes.
                - Use the rules provided below to evaluate the code.
                - Identify one issue at a time and respond in JSON format with:
                  line number, file path, commit hash, issue description, why it is an issue, and a suggested fix.
                - Rules:
                  1. All functions must have a summary comment or inheritdoc.
                  2. Avoid using 'SELECT *' in SQL queries; specify the columns explicitly.
                  3. Use PascalCase for method names in C#.
                  4. Avoid using string literals in nameof(); always reference variables directly.
                  5. All 'if' statements must use curly brackets.
                - Example response:
                  {
                    "line": 42,
                    "filePath": "main.cs",
                    "commitHash": "abcd1234",
                    "issueDescription": "Avoid hardcoding values.",
                    "whyIssue": "Hardcoded values are difficult to maintain.",
                    "fix": "Use constants instead.",
                    "last": false
                  }
                - Include "last: true" in the final response.
              `,
            },
          };
          ws.send(JSON.stringify(event));
          console.log("Sent response.create event.");
        };

        const postInlineComment = async (issue) => {
          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
          const { filePath, line, commitHash, issueDescription, whyIssue, fix } = issue;

          try {
            await octokit.pulls.createReviewComment({
              owner: process.env.GITHUB_REPOSITORY.split('/')[0],
              repo: process.env.GITHUB_REPOSITORY.split('/')[1],
              pull_number: process.env.PR_NUMBER,
              body: `${issueDescription}\n\n${whyIssue}\n\nSuggested Fix:\n\n\`${fix}\``,
              path: filePath,
              commit_id: commitHash,
              position: line,
            });
            console.log(`Comment posted for ${filePath} at line ${line}`);
          } catch (error) {
            console.error(`Failed to post comment: ${error.message}`);
          }
        };

        const processDiff = (ws) => {
          const diff = execSync(`git diff origin/${process.env.GITHUB_BASE_REF}`).toString();
          const changes = diff.split('diff --git')
            .slice(1)
            .map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0]?.match(/b\/([\S]+)/);
              const filePath = filePathMatch ? filePathMatch[1] : null;

              // Skip files in the workflows directory
              if (!filePath || filePath.includes('workflows/')) return null;

              const addedLines = [];
              lines.forEach((line, index) => {
                if (line.startsWith('+') && !line.startsWith('+++')) {
                  const blame = execSync(`git blame -L ${index + 1},${index + 1} --line-porcelain HEAD --  ${filePath} | head -n 1 | awk '{print $1}'`).toString();
                  const commitHash = blame.split(' ')[0];
                  addedLines.push({
                    lineNumber: index + 1,
                    lineDiff: line.slice(1),
                    commitHash,
                  });
                }
              });

              return { filePath, addedLines };
            })
            .filter(Boolean);

          changes.forEach(change => {
            const content = JSON.stringify(change, null, 2);
            addItemToConversation(ws, content, () => {
              requestResponse(ws);
            });
          });
        };

        connectToRealtimeAPI();
        EOF
        node generate_feedback.js
