name: ChatGPT Inline Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions: 
  contents: write
  pull-requests: write
  repository-projects: write
  
jobs:
  code_review:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for accurate git blame

    - name: Fetch PR Branch
      run: |
        git fetch origin ${{ github.event.pull_request.head.ref }}
        git checkout ${{ github.event.pull_request.head.ref }}

    - name: Install Dependencies
      run: npm install openai @octokit/rest@18.12.0

    - name: Fetch PR Diff
      id: get_diff
      run: |
        git diff origin/${{ github.event.pull_request.base.ref }} > pr_diff.txt

    - name: Generate ChatGPT Feedback
      id: generate_feedback
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        cat <<'EOF' > generate_feedback.js
        const fs = require('fs');
        const { execSync } = require('child_process');
        const { OpenAI } = require('openai');

        const openai = new OpenAI({
          apiKey: process.env.OPENAI_API_KEY,
        });

        function getCommitHash(filePath, lineNumber) {
          try {
            const command = `git blame -L ${lineNumber},${lineNumber} --line-porcelain -- ${filePath} | head -n 1 | awk '{print $1}'`;
            console.log(`blame command is :${command}`);
            return execSync(command).toString().trim();
          } catch (error) {
            console.error(`Failed to get commit hash for ${filePath} at line ${lineNumber}:`, error.message);
            return null;
          }
        }

        async function generateFeedback() {
          try {
            const diff = fs.readFileSync('pr_diff.txt', 'utf8');

            const changes = diff.split('diff --git').slice(1).map(change => {
              const lines = change.split('\n');
              const filePathMatch = lines[0].match(/b\/(\S+)/);
              let filePath = filePathMatch ? filePathMatch[1] : null;
              if(filePath && filePath.includes('workflows'))
              {
                filePath = `.github/${filePath}`;
              }
              const header = lines.find(line => line.startsWith('@@'));
              const position = header ? parseInt(header.match(/\+(\d+)/)[1], 10) : null;
              const addedLines = lines.filter(line => line.startsWith('+') && !line.startsWith('+++')).map(line => line.slice(1));
              const commitId = filePath && position ? getCommitHash(filePath, position) : null;
              return { filePath, position, addedLines, commitId };
            }).filter(change => change.filePath && change.addedLines.length > 0);

            // console.log('Parsed changes with commit IDs:', changes);

            const feedbacks = [];

            for (const { filePath, position, addedLines, commitId } of changes) {
              const prompt = `
                Review the following changes in the file \`${filePath}\`:
                ${addedLines.join('\n')}

                Provide feedback and suggestions for improvements, considering coding standards and logic.
              `;

              const maxTokens = Math.max(1000 - Math.ceil(prompt.length / 4), 50);
              console.log(`Dynamic max_tokens: ${maxTokens}`);

              try {
                const response = await openai.chat.completions.create({
                  model: 'gpt-4',
                  messages: [{ role: 'user', content: prompt }],
                  max_tokens: maxTokens,
                  n: 1,
                });

                const feedback = {
                  filePath,
                  position,
                  commitId,
                  body: response.choices[0].message.content,
                };

                feedbacks.push(feedback);
              } catch (apiError) {
                console.error(`Error while generating feedback for ${filePath}:`, apiError.message);
              }
            }

            fs.writeFileSync('feedbacks.json', JSON.stringify(feedbacks, null, 2));
          } catch (error) {
            console.error('Error during feedback generation:', error);
            process.exit(1);
          }
        }

        generateFeedback();
        EOF

        node generate_feedback.js

    - name: Post Inline Comments
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cat <<'EOF' > post_comments.js
        const fs = require('fs');
        const { Octokit } = require('@octokit/rest');

        const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
        console.log(`used g t is : ${btoa(process.env.GITHUB_TOKEN)}`);
        async function postComments() {
          try {
            const feedbacks = JSON.parse(fs.readFileSync('feedbacks.json', 'utf8'));
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const pull_number = parseInt(process.env.GITHUB_REF_NAME.split('/')[2], 10);

            for (const { filePath, position, commitId, body } of feedbacks) {
              console.log(`Posting comment for ${filePath} at position ${position} for commit ${commitId}`);

              try {
                await octokit.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  body,
                  path: filePath,
                  position,
                  commit_id: commitId,
                });
                console.log(`Comment posted for ${filePath} at position ${position}`);
              } catch (err) {
                console.error(`Failed to post comment for ${filePath}:${position}`, err.message);
              }
            }
          } catch (error) {
            console.error('Error during posting comments:', error);
            process.exit(1);
          }
        }

        postComments();
        EOF

        node post_comments.js
